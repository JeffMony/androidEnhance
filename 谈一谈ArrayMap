一、发生了什么问题？
最近遇到了几个问题，和ArrayMap相关的，比较棘手，在研究这些问题的过程中，学习了ArrayMap，在这里和大家分享一下吧。

首先列出遇到的问题：

1.问题1，http://jira.n.xiaomi.com/browse/MIUI-1294203

java.lang.ClassCastException
1
2
3
4
5
6
7
8
9
10
11
12
13
14
det: java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Object[]
at android.util.ArrayMap.allocArrays(ArrayMap.java:188)
at android.util.ArrayMap.put(ArrayMap.java:463)
at android.os.Bundle.putParcelable(Bundle.java:402)
at android.net.wifi.WifiScanner.startScan(WifiScanner.java:739)
at com.android.server.wifi.WifiStateMachine.startScanNative(WifiStateMachine.java:1826)
at com.android.server.wifi.WifiStateMachine.handleScanRequest(WifiStateMachine.java:1729)
at com.android.server.wifi.WifiStateMachine.-wrap26(WifiStateMachine.java)
at com.android.server.wifi.WifiStateMachine$DriverStartedState.processMessage(WifiStateMachine.java:4940)
at com.android.internal.util.StateMachine$SmHandler.processMsg(StateMachine.java:980)
at com.android.internal.util.StateMachine$SmHandler.handleMessage(StateMachine.java:799)
at android.os.Handler.dispatchMessage(Handler.java:102)
at android.os.Looper.loop(Looper.java:163)
at android.os.HandlerThread.run(HandlerThread.java:61)
2.问题2，http://jira.n.xiaomi.com/browse/MIUI-1319146

java.util.ConcurrentModificationException
1
2
3
4
5
6
7
8
9
10
11
12
det: java.util.ConcurrentModificationException
at android.util.ArrayMap.put(ArrayMap.java:502)
at android.os.BaseBundle.putInt(BaseBundle.java:558)
at com.android.server.location.GnssLocationProvider.updateStatus(GnssLocationProvider.java:1225)
at com.android.server.location.GnssLocationProvider.stopNavigating(GnssLocationProvider.java:1507)
at com.android.server.location.GnssLocationProvider.updateRequirements(GnssLocationProvider.java:1295)
at com.android.server.location.GnssLocationProvider.handleSetRequest(GnssLocationProvider.java:1243)
at com.android.server.location.GnssLocationProvider.-wrap30(Unknown Source:0)
at com.android.server.location.GnssLocationProvider$ProviderHandler.handleMessage(GnssLocationProvider.java:2185)
at android.os.Handler.dispatchMessage(Handler.java:105)
at android.os.Looper.loop(Looper.java:164)
at android.os.HandlerThread.run(HandlerThread.java:65)
这两个问题都有讨论的价值，讨论的前提，当然是要搞清楚ArrayMap的原理。

二、为什么使用ArrayMap?
一提到ArrayMap，我们想到java上使用的HashMap，android一般使用java的api，为什么这里要重新写一个ArrayMap，其实从HashMap的实现可以看出来，HashMap内部维护一个链表数组HashMapEntry[] table，每个Entry链表包含所有Hash值相同的Entry，新增加了HashMapEntry对象来封装key-value，需要的内存增多，HashMap每次扩容是2倍，而ArrayMap每次是1.5倍（具体的扩容策略还要具体分析），每次扩容的时候HashMap要重新构建整个Hash表，ArrayMap直接数组copy就可以的。

Android平台使用Dalvik虚拟机，对内存和处理器速度要求比较高，内存尽可能少用。针对HashMap浪费内存切扩容策略耗时，所以Android单独设计了ArrayMap。

参考官网对ArrayMap的阐述：

ArrayMap是一个通用的key-> value映射数据结构，设计为比传统的HashMap有更高的内存效率。它通过Array数组来实现映射关系，一个Integer Array来存储Hash值，一个Object Array来存储key/value Pairs, 它避免创建额外的Entry对象来存储数据，同时有效的控制Array的增长（增加entry时，它仅需要复制数组，而不是重建一个hash map表）。

对于含有大量数据的Map表，ArrayMap比传统的HashMap慢，因为它使用二分法查找，插入或者删除需要操作Array中的Entry。对于包含几百个数据的Map表，ArrayMap对比HashMap性能差异不明显，低于50%。

ArrayMap中两个重要的数据：Object[] mArray（存储对应的key与value）与int[] mHash（存储key的hash值）

下面是ArrayMap的核心代码：

ArrayMap.java
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
int[] mHashes;  //按大小排列
Object[] mArray;//mHashes的两倍长度，index<<1和(index<<1)+1分别存储hash值对应的key和value
int mSize;
//查找
public V get(Object key) {
    final int index = indexOfKey(key);
    return index >= 0 ? (V)mArray[(index<<1)+1] : null;
}
 
 
public int indexOfKey(Object key) {
    return key == null ? indexOfNull()
            : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());
}
//删除
public V remove(Object key) {
    final int index = indexOfKey(key);
    if (index >= 0) {
        return removeAt(index);
    }
 
    return null;
}
 
//添加   
public V put(K key, V value) {
    final int osize = mSize;
    final int hash;
    int index;
    if (key == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();
        index = indexOf(key, hash);
    }
    if (index >= 0) {
        index = (index<<1) + 1;
        final V old = (V)mArray[index];
        mArray[index] = value;
        return old;
    }
 
    index = ~index;
    if (osize >= mHashes.length) {
        final int n = osize >= (BASE_SIZE*2) ? (osize+(osize>>1))
                : (osize >= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);
 
        if (DEBUG) Log.d(TAG, "put: grow from " + mHashes.length + " to " + n);
 
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
 
        if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
            throw new ConcurrentModificationException();
        }
 
        if (mHashes.length > 0) {
            if (DEBUG) Log.d(TAG, "put: copy 0-" + osize + " to 0");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
 
        freeArrays(ohashes, oarray, osize);
    }
 
    if (index < osize) {
        if (DEBUG) Log.d(TAG, "put: move " + index + "-" + (osize-index)
                + " to " + (index+1));
        System.arraycopy(mHashes, index, mHashes, index + 1, osize - index);
        System.arraycopy(mArray, index << 1, mArray, (index + 1) << 1, (mSize - index) << 1);
    }
 
    if (CONCURRENT_MODIFICATION_EXCEPTIONS) {
        if (osize != mSize || index >= mHashes.length) {
            throw new ConcurrentModificationException();
        }
    }
    /**
    ** 工作主要是：
    ** 1.检索插入的位置；
    ** 2.超过限制容量如何扩容；
    ** 3.将key的hash放在mHash数组中相应位置，将key-value对象放在mArray中。
    **/
    mHashes[index] = hash;
    mArray[index<<1] = key;
    mArray[(index<<1)+1] = value;
    mSize++;
    return null;
}
 
//搜索key的hash放在hash数组中的索引
int indexOf(Object key, int hash) {
    final int N = mSize;
 
    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }
 
    int index = binarySearchHashes(mHashes, N, hash);
 
    // If the hash code wasn't found, then we have no entry for this key.
    if (index < 0) {
        return index;
    }
 
    // If the key at the returned index matches, that's what we want.
    if (key.equals(mArray[index<<1])) {
        return index;
    }
 
    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end < N && mHashes[end] == hash; end++) {
        if (key.equals(mArray[end << 1])) return end;
    }
 
    // Search for a matching key before the index.
    for (int i = index - 1; i >= 0 && mHashes[i] == hash; i--) {
        if (key.equals(mArray[i << 1])) return i;
    }
 
    // Key not found -- return negative value indicating where a
    // new entry for this key should go.  We use the end of the
    // hash chain to reduce the number of array entries that will
    // need to be copied when inserting.
    return ~end;
}
查找过程：

定位一个key的位置通过key和它的hash值两个参数来实现，如果定位成功直接返回value  mArray[(index<<1)+1]。步骤如下：

1、先二分查找mHashes，找到key对应的hash值mHashes[index]（可能有多个相邻对象的hash值相同）

2、匹配此mHashes[index]对应的key值mArray[index<< 1]与查找的Key是否相同，相同则直接返回定位index

3、若步骤2匹配不上，再分析mHashes中index临近位置且hash值相同对象（如mHashes[index+1]，mHashes[index+2] … mHashes[index-1],  mHashes[index-2] …. ），若其对应的key与Key相同，相同则返回Key匹配的Index

4、如果有定位到Index就返回对应的Value 返回(V)mArray[(Index<<1)+1]；否则返回null



删除过程和插入过程中重要的方法也是indexOf(...)方法，关注一下ArrayMap的数据扩容算法：

final int n = osize >= (BASE_SIZE*2) ? (osize+(osize>>1))
        : (osize >= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);
超过2*BASE_SIZE，扩容2倍，在BASE_SIZE与2*BASE_SIZE之间，扩至2*BASE_SIZE。



接下来讨论下ArrayMap最重要的缓存机制：当需要分配新的数组长度是4或者8时，先确认是否可从缓存中复用，有缓存则优先使用缓存

ArrayMap缓存机制
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
public  static Object[]  mBaseCache;
public  static int       mBaseCacheSize;
public  static Object[]  mTwiceBaseCache;
public  static int       mTwiceBaseCacheSize;
 
 
//缓存过程
private static void freeArrays(final int[] hashes, final Object[] array, final int size) {
    if (hashes.length == (BASE_SIZE*2)) {
        synchronized (ArrayMap.class) {
            if (mTwiceBaseCacheSize < CACHE_SIZE) {
                array[0] = mTwiceBaseCache;
                array[1] = hashes;
                for (int i=(size<<1)-1; i>=2; i--) {
                    array[i] = null;
                }
                mTwiceBaseCache = array;
                mTwiceBaseCacheSize++;
                if (DEBUG) Log.d(TAG, "Storing 2x cache " + array
                        + " now have " + mTwiceBaseCacheSize + " entries");
            }
        }
    } else if (hashes.length == BASE_SIZE) {
        synchronized (ArrayMap.class) {
            if (mBaseCacheSize < CACHE_SIZE) {
                array[0] = mBaseCache;
                array[1] = hashes;
                for (int i=(size<<1)-1; i>=2; i--) {
                    array[i] = null;
                }
                mBaseCache = array;
                mBaseCacheSize++;
                if (DEBUG) Log.d(TAG, "Storing 1x cache " + array
                        + " now have " + mBaseCacheSize + " entries");
            }
        }
    }
}
 
 
//分配新数组，复用过程
private void allocArrays(final int size) {
    if (mHashes == EMPTY_IMMUTABLE_INTS) {
        throw new UnsupportedOperationException("ArrayMap is immutable");
    }
    if (size == (BASE_SIZE*2)) {
        synchronized (ArrayMap.class) {
            if (mTwiceBaseCache != null) {
                final Object[] array = mTwiceBaseCache;
                mArray = array;
                mTwiceBaseCache = (Object[])array[0];
                mHashes = (int[])array[1];
                array[0] = array[1] = null;
                mTwiceBaseCacheSize--;
                if (DEBUG) Log.d(TAG, "Retrieving 2x cache " + mHashes
                        + " now have " + mTwiceBaseCacheSize + " entries");
                return;
            }
        }
    } else if (size == BASE_SIZE) {
        synchronized (ArrayMap.class) {
            if (mBaseCache != null) {
                final Object[] array = mBaseCache;
                mArray = array;
                mBaseCache = (Object[])array[0];
                mHashes = (int[])array[1];
                array[0] = array[1] = null;
                mBaseCacheSize--;
                if (DEBUG) Log.d(TAG, "Retrieving 1x cache " + mHashes
                        + " now have " + mBaseCacheSize + " entries");
                return;
            }
        }
    }
 
    mHashes = new int[size];
    mArray = new Object[size<<1];
}
缓存及复用过程的代码比较难以理解，缓存一对hashes和array数组时，先把静态变量缓存old cache放到array[0]，hashes放到array[1]，array[2]到array[7]赋值为null，最后再将这个array赋值给静态变量cache。通过巧妙的复用array，避免了新建对象来保存缓存数组。

三、为什么会发生上面的问题？
1.java.lang.ClassCastException

at android.util.ArrayMap.allocArrays(ArrayMap.java:188)
这是发生问题的地方，具体发生问题的代码是：mBaseCache = (Object[])array[0];



查看mBaseCache对象的调用，发现仅仅在freeArrays和allocArrays两个函数有直接调用，操作过程也添加了同步锁，且仅仅freeArrays中有对mBaseCache的赋值操作（allocArrays是复用上一次缓存的mBaseCache）。allocArrays中取object[]转型错误，很可能是freeArrays中产生了脏数据。

我们再仔细查看freeArrays的代码，新缓存的mBaseCache[0]被赋值为mBaseCache，而在allocArrays中复用时读出来的值类型不对，说明”array[0] = mBaseCache”操作后又重新修改了array[0] 。

freeArrays函数操作的hashes和array都是需要回收的对象，我们看看freeArrays四处调用，其中ensureCapacity(int minimumCapacity) 和 put(K key, V value)执行freeArrays前ArrayMap已经不再引用这对hashes和value，而removeAt(int index)和clear()是执行freeArrays回收操作后再对ArrayMap的mHashes和mArray重新赋值，也就是其它线程有可能在freeArrays“array[0] = mBaseCache”操作后对mArray进行修改，产生脏数据。对array[0] 进行重新赋值，可能是执行put操作时，新增的key的hash值刚好排第一，或者remove操作时删除的刚好是第一个key，导致array后面的值前移。

从代码中可以看出来，ArrayMap是非线程安全的，下面就按照我们上面分析来构造这种场景：

（1）A线程释放长度为4或者8的数据；

（2）B线程在A线程执行" array[0] = mBaseCache "后修改array[0]

下面是测试代码：

testArrayMap.java
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
private void arrayMapClassCastExceptionDemo2() {
    final ArrayMap<String, String> mMap = new ArrayMap<String, String>(4);
    new Thread() {
        @Override
        public void run() {
            for(int i=0;i<10000; i++) {
                ArrayMap<String, String> map= new ArrayMap<String, String>(4);
                mMap.putAll(map);
                mMap.clear();
 
            }
        }
    }.start();
 
    new Thread() {
        @Override
        public void run() {
            for(int i=0;i<10000;i++) {
                try {
                    mMap.remove("test1");
                    mMap.put("test1", "haha");
                } catch (ArrayIndexOutOfBoundsException exception) {
 
                }
            }
        }
    }.start();
}
很容易出现这样的问题。我们用了很长的篇幅分析了这个问题，既然ArrayMap是非线程安全的，如果这样使用的话，肯定会出现问题的，那么google没有注意到这个问题吗？

下面是google修复这个问题的代码：

https://android.googlesource.com/platform/frameworks/base/+/d0ecb1ed10725a6b2c84d64e212984cd4c0d26d2

简而言之，就是充分考虑了我们之前分析的情况，避免出现ClassCastException，这个修复也会抛出java.util.ConcurrentModificationException异常，但是很明显在告诉调用者存在线程问题，比之前的提示更加人性化。

2.java.util.ConcurrentModificationException

Android8.0之后，google提交了修复代码修复了ClassCastException问题，但是如果在多个线程中对ArrayMap添加和删除的话，还是会出现ConcurrentModificationException问题，说明google不建议在多线程中使用ArrayMap。



至于为什么不将ArrayMap变成线程安全的，这样会使ArrayMap的效率大打折扣。
